-- | Module:    Database.PostgreSQL.Protocol.Builders
-- Description: Builders for PostgreSQL messages.
-- Copyright:   © 2015-2019 Patryk Zadarnowski <pat@jantar.org>
-- License:     BSD3
-- Maintainer:  Patryk Zadarnowski «pat@jantar.org»
-- Stability:   experimental
-- Portability: portable
--
-- This module defines low-level builders for all defined PostgreSQL messages.
-- At this level of abstraction, all message fields are rendered directly as
-- binary data, with little or no marshalling into any more meaningful Haskell
-- types, in order to provided higher-level libraries with maximum possible
-- freedom of behaviour.

{-# LANGUAGE OverloadedStrings #-}

module Database.PostgreSQL.Protocol.Builders where

import Data.Bifunctor
import Data.ByteString (ByteString)
import Data.ByteString.Builder
import Data.Int
import Data.Word

import Database.PostgreSQL.Protocol.Internal.Builders
import Database.PostgreSQL.Protocol.Types

-- * Session Message Builders

-- | Builder for 'SessionMessage' values.  In most cases, this function should
-- probably be avoided in favour of a direct use of the individual message type
-- builders defined below.
sessionMessage :: SessionMessage -> Builder
sessionMessage (STARTUP_MESSAGE m n ps) = startupMessage' m n ps
sessionMessage (CANCEL_REQUEST pid secret) = cancelRequestMessage pid secret
sessionMessage (SSL_REQUEST) = sslRequestMessage

-- | Prepares a startup message with the current version of the PostgreSQL
-- frontend/backend protocol; same as
-- @startupMessage' 'CURRENT_MAJOR_VERSION' 'CURRENT_MINOR_VERSION'@.
startupMessage ::[(ByteString, LazyByteString)] -> Builder
startupMessage = startupMessage' CURRENT_MAJOR_VERSION CURRENT_MINOR_VERSION

-- | A message of the form “@'STARTUP_MESSAGE' m n ps@” requests initiation of
-- a new database connection using protocol version @m.n@, optionally
-- configuring some session parameters to the specified default values. Besides
-- the usual set of server configuration parameters that can be configured at
-- runtime using the SQL @SET@ command, 'STARTUP_MESSAGE' accepts the following
-- three session-specific parameters:
--
--   * @user@, the database user name used to use,
--   * @database@, the target database, and
--   * @options@, command-line arguments for the backend.
--
-- The @user@ parameter is mandatory, but the other two may be omitted,
-- defaulting to a database with the same name as the @user@ and an empty set
-- of command-line arguments.  In addition, the use of @options@ parameter has
-- been deprecated in favour of setting individual run-time parameters.
--
-- The major and minor protocol version should be always set to
-- 'CURRENT_MAJOR_VERSION' and 'CURRENT_MINOR_VERSION', respectively, since
-- PostgreSQL does not maintain backward compatibility between releases of its
-- protocol, and the current version (3.0) is the only version guaranteed to be
-- supported by this library. Accordingly, this function should never be used
-- (unless you /really/ know what you're doing!) For every day use
-- 'startupMessage' (which requests current protocol version implicitly) should
-- be always used in preference to @startupMessage'@.
startupMessage' :: Foldable t =>
  Word16 -> Word16 -> t (ByteString, LazyByteString) -> Builder
startupMessage' m n ps = withMessageSizeHeader $
  int32BE (fromIntegral m * 65536 + fromIntegral n) <>
  foldMap (uncurry mappend . bimap byteStringNul lazyByteStringNul) ps <>
  char8 '\0'

-- | A message of the form “@'CANCEL_REQUEST' pid secret@” requests
-- cancellation of a query currently being executed on the server by another
-- backend process with the process ID @pid@. In order to demonstrate authority
-- to interact with this backend process, the frontend must include in the
-- message the unique 32-bit key @secret@ generated by the backend process and
-- supplied to the frontend in a 'BACKEND_KEY_DATA' message sent as part of the
-- session establishment protocol of the targeted communication session.
cancelRequestMessage :: ProcessID -> Word32 -> Builder
cancelRequestMessage pid secret = withMessageSizeHeader $
  word32BE 80877102 <>
  word32BE pid <>
  word32BE secret

-- | Requests establishment of an SSL-protected communication session.  The
-- server should respond with an 'SSLResponse' message described below.
sslRequestMessage :: Builder
sslRequestMessage = withMessageSizeHeader $
  int32BE 80877103

-- | Builder for the special-case response to an 'SSL_REQUEST' message.  In
-- most cases, this function should probably be avoided in favour of a direct
-- use of the individual message type builders defined below.
sslResponseMessage :: SSLResponse -> Builder
sslResponseMessage (SSL_REQUEST_ACCEPTED)   = sslRequestAcceptedMessage
sslResponseMessage (SSL_REQUEST_REJECTED)   = sslRequestRejectedMessage
sslResponseMessage (SSL_REQUEST_FAILED nfs) = sslRequestFailedMessage nfs

-- | Indicates to the frontend that the backend has accepted the 'SSL_REQUEST'.
-- The frontend should perform a standard SSL startup handshake as per SSL
-- Specification and, if successful, proceed to send the usual
-- 'STARTUP_MESSAGE' or 'CANCEL_REQUEST' over the newly-established SSL
-- channel.
sslRequestAcceptedMessage :: Builder
sslRequestAcceptedMessage = char8 'S'

-- | Indicates to the frontend that the backend has rejected the 'SSL_REQUEST'.
-- The frontend has an option of abandoning the connection by closing the
-- underlying socket, or proceeding with an unencrypted session by sending the
-- usual 'STARTUP_MESSAGE' or 'CANCEL_REQUEST' over the same socket without
-- encryption.
sslRequestRejectedMessage :: Builder
sslRequestRejectedMessage = char8 'N'

-- | Indicates to the frontend that the backend does not understand
-- 'SSL_REQUEST' messages. This would only occur if the server predates the
-- addition of SSL support to PostgreSQL. Such servers are now very ancient,
-- and likely do not exist in the wild anymore. In this case the connection
-- must be closed, but the frontend might choose to open another, fresh
-- connection and proceed without requesting SSL. The notice returned by the
-- backend is unlikely to continue meaningful error information and should most
-- likely be ignored.
sslRequestFailedMessage :: Foldable t => t NoticeField -> Builder
sslRequestFailedMessage = errorResponseMessage


-- * Frontend Message Builders

-- | Builder for 'FrontendMessage' values.  In most cases, this function should
-- probably be avoided in favour of a direct use of the individual message type
-- builders defined below.
frontendMessage :: FrontendMessage -> Builder
frontendMessage (BIND p s pfs pvs rfs)         = bindMessage p s pfs pvs rfs
frontendMessage (CLOSE k x)                    = closeMessage k x
frontendMessage (COPY_IN_DATA content)         = copyDataMessage content
frontendMessage (COPY_IN_DONE)                 = copyDoneMessage
frontendMessage (COPY_FAIL msg)                = copyFailMessage msg
frontendMessage (DESCRIBE k x)                 = describeMessage k x
frontendMessage (EXECUTE p n)                  = executeMessage p n
frontendMessage (FLUSH)                        = flushMessage
frontendMessage (FUNCTION_CALL oid pfs pvs rf) = functionCallMessage oid pfs pvs rf
frontendMessage (PARSE s q pts)                = parseMessage s q pts
frontendMessage (PASSWORD_MESSAGE x)           = passwordMessage x
frontendMessage (QUERY q)                      = queryMessage q
frontendMessage (SYNC)                         = syncMessage
frontendMessage (TERMINATE)                    = terminateMessage

-- | A message of the form “@'BIND' p s pfs pvs rfs@” requests /binding/
-- (i.e., creation) of a new portal @p@ to an existing parsed statement @s@,
-- with parameter formats @pfs@, parameter values @pvs@ and result formats
-- @rfs@.  The default /unnamed portal/ and/or /unnamed statement/ can be
-- selected by setting @p@ and/or @s@ to an empty byte string
-- ('Data.ByteString.null').
--
-- The @pvs@ array must provide a field value (possibly 'Nothing' for SQL
-- @NULL@) for every actual parameter mentioned in the SQL command @s@ using
-- the @?@ or @$/n/@ syntax.  Each of these values can be encoded in either the
-- default textual or binary transfer format (both are represented in @Value@
-- as simple byte strings) and the actual choice of the format is determined by
-- the @pfs@ array. The @pfs@ array can be empty (indicating that all
-- parameters are encoded using the default textual format), singleton
-- (indicating that all parameters are encoded using the same explicitly
-- specified format) or else must have the same length as the @pvs@ array,
-- specifying the transfer formats individually for each parameter value.
--
-- Likewise, the @rfs@ array, which determines the transfer formats expected by
-- the frontend for any result values returned by the backend, can be left
-- empty, requesting the backend to use the default textual encoding of all
-- result values), specified as a singleton array (requesting the same encoding
-- for all result fields), or else match the number of columns in the result
-- set, thus specifying an individual format for each column.
bindMessage :: (Foldable t1, Foldable t2, Foldable t3) =>
  ByteString -> ByteString -> t1 Format -> t2 (Maybe LazyByteString) -> t3 Format -> Builder
bindMessage p s pfs pvs rfs = withMessageHeader 'B' $
  byteStringNul p <>
  byteStringNul s <>
  array16BE word16BE pfs <>
  array16BE pgValue pvs <>
  array16BE word16BE rfs

-- | A message of the form “@'CLOSE' k x@” requests that the session object @x@
-- of type @k@ (either a 'STATEMENT_OBJECT' created by the 'PARSE' message or a
-- 'PORTAL_OBJECT' created with 'BIND') is no longer required, and that its
-- underlying resources should be released by the server for other uses.
closeMessage :: SessionObjectKind -> SessionObjectName -> Builder
closeMessage k x = withMessageHeader 'C' $
  word8 k <>
  byteStringNul x

-- | Transmits a chunk of a @COPY@ data string between the frontend to the
-- backend.  The actual format of the stream data is determined by the user as
-- part of the requesting @COPY@ command and communicated by the backend back
-- to the frontend in the 'COPY_IN_RESPONSE', 'COPY_OUT_RESPONSE' or
-- 'COPY_BOTH_RESPONSE' message that heralds commencement of the @COPY@
-- subprotocol session.
--
-- By convention, backends are expected to send complete data rows in a
-- 'COPY_OUT_DATA' message, but frontends are allowed to divide stream data
-- into chunks arbitrarily without regard of data row boundaries.
copyDataMessage :: LazyByteString -> Builder
copyDataMessage content = withMessageHeader 'd' $
  lazyByteString content

-- | Sent after the final 'COPY_IN_DATA' or 'COPY_OUT_DATA' message of a given
-- @COPY@ subprotocol session, indicates successful completion of an entire
-- @COPY@ data stream.
copyDoneMessage :: Builder
copyDoneMessage = withMessageHeader 'c' mempty

-- | A message of the form “@'COPY_FAIL' msg@” should be sent by the frontend
-- to indicate inability to supply the required @COPY@ data stream. The byte
-- string @msg@ should provide a human-readable description of the exact error
-- condition behind the failure.
copyFailMessage :: LazyByteString -> Builder
copyFailMessage msg = withMessageHeader 'f' $
  lazyByteStringNul msg

-- | A message of the form “@'DESCRIBE' k x@” requests that the backend provide
-- details about the session object @x@ of type @k@ (either a
-- 'STATEMENT_OBJECT' created by the 'PARSE' message or a 'PORTAL_OBJECT'
-- created with 'BIND'.) The backend should respond with a
-- 'PARAMETER_DESCRIPTION' or 'ROW_DESCRIPTION' message for statement and
-- portal objects, respectively.
describeMessage :: SessionObjectKind -> SessionObjectName -> Builder
describeMessage k x = withMessageHeader 'D' $
  word8 k <> byteStringNul x

-- | A message of the form “@'EXECUTE' p n@” requests execution of a bound
-- portal @p@. If @n@ is greater than zero and @p@ represents an SQL query, at
-- most @n@ data rows should be returned by the backend; otherwise, the @n@
-- parameter is ignored and all data rows should be returned. If @p@ returns a
-- row set and @n@ is negative, the results are left unspecified by the
-- protocol.
executeMessage :: SessionObjectName -> Int32 -> Builder
executeMessage p n = withMessageHeader 'E' $
  byteStringNul p <>
  int32BE n

-- | Indicates that the backend should immediately return any pending command
-- result data.
flushMessage :: Builder
flushMessage =  withMessageHeader 'H' mempty

-- | A message of the form “@'FUNCTION_CALL' oid afs avs rf@” requests
-- execution of a PostgreSQL function with the given object ID @oid@, supplying
-- it an array of argument values @avs@ encoded in the transfer format
-- specified by the array @afs@, and expecting the function's sole result value
-- to be encoded using the transfer format @rf@. As for 'BIND' messages, @afs@
-- can be an empty array if all argument values are supplied in the default
-- text format, a singleton array to specify the same explicit transfer format
-- for all arguments, or else it must specify precisely one format for each of
-- the argument values in @avs@.
functionCallMessage :: (Foldable t1, Foldable t2) =>
  ObjectID -> t1 Format -> t2 (Maybe LazyByteString) -> Format -> Builder
functionCallMessage oid afs avs rf = withMessageHeader 'F' $
  word32BE oid <>
  array16BE word16BE afs <>
  array16BE pgValue avs <>
  word16BE rf

-- | A message of the form “@'PARSE' s q pts@” requests creation of a new
-- prepared statement object with the name @x@ in the current session from the
-- SQL command @q@.  The statement name can be set to 'Data.ByteString.null' to
-- create the default unnamed statement. The array @pts@ specifies object IDs
-- of PostgreSQL types for any query parameters appearing in @q@. It is not
-- required to specify types for all query parameters and may even be left
-- empty if not required; the types of any parameters omitted from @pts@ are
-- then inferred directly from the query string @q@ itself.
parseMessage :: Foldable t => ByteString -> LazyByteString -> t ObjectID -> Builder
parseMessage s q pts = withMessageHeader 'P' $
  byteStringNul s <>
  lazyByteStringNul q <>
  array16BE word32BE pts

-- | Supplies a password string in response to an 'AUTHENTICATION' message from
-- the backend, encrypted if required using the method requested by the
-- backend.
passwordMessage :: LazyByteString -> Builder
passwordMessage secret = withMessageHeader 'p' $
  lazyByteStringNul secret

-- | A message of the form “@'QUERY' q@” requests a streamlined processing of the
-- SQL command @q@, which should be parsed, bound, executed and eventually
-- closed by the backend without further intervention by the frontend. The
-- backend is allowed to implement this interface using the default unnamed
-- session statement and portal, thus overwriting any such statements created
-- in the current session explicitly.
queryMessage :: LazyByteString -> Builder
queryMessage q = withMessageHeader 'Q' $
  lazyByteStringNul q

-- | Requests synchronisation point after a failed query in the backend. After
-- receiving a “'SYNC'” message, the backend should exit error recovery mode
-- and prepare itself to receive the next valid query from the frontend.
syncMessage :: Builder
syncMessage = withMessageHeader 'S' mempty

-- | Requests graceful termination of a communication session. After
-- transmitting a “'TERMINATE'” message, the frontend should refrain from
-- sending any further messages to the backend and immediately close the
-- connection socket.
terminateMessage :: Builder
terminateMessage =  withMessageHeader 'X' mempty


-- * Backend Message Builders

-- | Builder for 'BackendMessage' values. In most cases, this function should
-- be avoided in favour of a direct use of the individual message type builders
-- defined below.
backendMessage :: BackendMessage -> Builder
backendMessage (AUTHENTICATION_RESPONSE ar)    = authenticationResponseMessage ar
backendMessage (BACKEND_KEY_DATA pid k)        = backendKeyDataMessage pid k
backendMessage (BIND_COMPLETE)                 = bindCompleteMessage
backendMessage (CLOSE_COMPLETE)                = closeCompleteMessage
backendMessage (COMMAND_COMPLETE rt)           = commandCompleteMessage rt
backendMessage (COPY_OUT_DATA content)         = copyDataMessage content
backendMessage (COPY_OUT_DONE)                 = copyDoneMessage
backendMessage (COPY_IN_RESPONSE f fs)         = copyInResponseMessage f fs
backendMessage (COPY_OUT_RESPONSE f fs)        = copyOutResponseMessage f fs
backendMessage (COPY_BOTH_RESPONSE f fs)       = copyBothResponseMessage f fs
backendMessage (DATA_ROW vs)                   = dataRowMessage vs
backendMessage (EMPTY_QUERY_RESPONSE)          = emptyQueryResponseMessage
backendMessage (ERROR_RESPONSE nfs)            = errorResponseMessage nfs
backendMessage (FUNCTION_CALL_RESPONSE v)      = functionCallResponseMessage v
backendMessage (NO_DATA)                       = noDataMessage
backendMessage (NOTICE_RESPONSE nfs)           = noticeResponseMessage nfs
backendMessage (NOTIFICATION_RESPONSE pid c x) = notificationResponseMessage pid c x
backendMessage (PARAMETER_DESCRIPTION pts)     = parameterDescriptionMessage pts
backendMessage (PARAMETER_STATUS p x)          = parameterStatusMessage p x
backendMessage (PARSE_COMPLETE)                = parseCompleteMessage
backendMessage (PORTAL_SUSPENDED)              = portalSuspendedMessage
backendMessage (READY_FOR_QUERY ts)            = readyForQueryMessage ts
backendMessage (ROW_DESCRIPTION fds)           = rowDescriptionMessage fds

-- | Sent by a backend in response to a 'STARTUP_MESSAGE' with details of any
-- authentication requirements imposed on the frontend. In Chapter 49 of
-- PostgreSQL manual, this is documented as an array of individual messages,
-- but in the Haskell implementation we combine them into a single
-- 'AUTHENTICATION_RESPONSE' constructor to simplify processing.
authenticationResponseMessage :: AuthenticationResponse -> Builder
authenticationResponseMessage (AUTHENTICATION_OK)                        = authenticationOkMessage
authenticationResponseMessage (AUTHENTICATION_KERBEROS_V5)               = authenticationKerberosV5Message
authenticationResponseMessage (AUTHENTICATION_CLEARTEXT_PASSWORD)        = authenticationCleartextPasswordMessage
authenticationResponseMessage (AUTHENTICATION_MD5_PASSWORD salt)         = authenticationMD5PasswordMessage salt
authenticationResponseMessage (AUTHENTICATION_SCM_CREDENTIAL)            = authenticationSCMCredentialMessage
authenticationResponseMessage (AUTHENTICATION_GSS)                       = authenticationGSSMessage
authenticationResponseMessage (AUTHENTICATION_GSS_CONTINUE content)      = authenticationGSSContinueMessage content
authenticationResponseMessage (AUTHENTICATION_SSPI)                      = authenticationSSPIMessage
authenticationResponseMessage (AUTHENTICATION_SASL mechanisms)           = authenticationSASLMessage mechanisms
authenticationResponseMessage (AUTHENTICATION_SASL_CONTINUE content)     = authenticationSASLContinueMessage content
authenticationResponseMessage (AUTHENTICATION_SASL_FINAL content)        = authenticationSASLFinalMessage content
authenticationResponseMessage (AUTHENTICATION_MISCELLANEOUS tag content) = authenticationMiscellaneousMessage tag content

-- | Issued by the backend to signify successful authentication of the
-- frontend's credentials.
authenticationOkMessage :: Builder
authenticationOkMessage = withAuthenticationResponseHeader 0 mempty

-- | Issued by the backend to initiate Kerberos V5 authentication dialogue,
-- described separately in Kerberos specification. This authentication method
-- is no longer supported by recent versions of PostgreSQL software.
authenticationKerberosV5Message :: Builder
authenticationKerberosV5Message = withAuthenticationResponseHeader 2 mempty

-- | Issued by the backend to request clear-text password authentication.  The
-- frontend should respond with a 'PASSWORD_MESSAGE' containing an unencrypted
-- text of the user's password.
authenticationCleartextPasswordMessage :: Builder
authenticationCleartextPasswordMessage = withAuthenticationResponseHeader 3 mempty

-- | A message of the form “@AUTHENTICATION_MD5_PASSWORD s@” is issued by the
-- backend to request MD5-based password authentication with the specified
-- 32-bit /salt/ @s@.  The frontend should respond with a 'PASSWORD_MESSAGE x',
-- in which @x@ is a byte string derived from the user's login name @u@,
-- password @p@ and the supplied salt @ss@ as follows:
--
-- @
--      "md5" <> md5 (md5 (/p/ <> /u/) <> /ss/
-- @
--
-- where /s/ is a 4-byte byte string obtained from the big-endian encoding of
-- the supplied salt @s@, and @md5(x)@ is a function that returns a 32-byte
-- byte string obtained from the lower-case hexadecimal encoding of the MD5
-- signature of @x@.
authenticationMD5PasswordMessage :: Word32 -> Builder
authenticationMD5PasswordMessage salt = withAuthenticationResponseHeader 5 $
  word32BE salt

-- | Issued by the backend to request SCM credential authentication, possible
-- only on connections over local Unix-domain sockets on platforms that support
-- SCM credential messages. The frontend must issue an SCM credential message
-- and then send a single data byte. The contents of the data byte are
-- uninteresting; it's only used to ensure that the server waits long enough to
-- receive the credential message. If the credential is acceptable, the server
-- responds with an 'AUTHENTICATION_OK', otherwise it responds with an
-- 'ERROR_RESPONSE'. This message type is only issued by versions of PostgreSQL
-- servers earlier than 9.1 and may eventually be removed from the protocol
-- specification.
authenticationSCMCredentialMessage :: Builder
authenticationSCMCredentialMessage = withAuthenticationResponseHeader 6 mempty

-- | Issued by the backend to request GSS credential authentication. The
-- frontend should respond by initiating a GSSAPI negotiation, sending a
-- 'PASSWORD_MESSAGE' with the first part of the GSSAPI data stream. If further
-- messages are needed, the server will respond with an
-- 'AUTHENTICATION_GSS_CONTINUE' message.
authenticationGSSMessage :: Builder
authenticationGSSMessage = withAuthenticationResponseHeader 7 mempty

-- | Issued by the backend as a response to the previous step of GSSAPI or SSPI
-- negotiation, i.e., an 'AUTHENTICATION_GSS', 'AUTHENTICATION_SSPI' or an
-- earlier 'AUTHENTICATION_GSS_CONTINUE' message. If the GSSAPI or SSPI data in
-- this message indicates more data is needed to complete the authentication,
-- the frontend must send that data as another 'PASSWORD_MESSAGE'.  If GSSAPI
-- or SSPI authentication is completed by this message, the server will
-- eventually send 'AUTHENTICATION_OK' to indicate successful authentication or
-- 'ERROR_RESPONSE' to indicate failure.
authenticationGSSContinueMessage :: LazyByteString -> Builder
authenticationGSSContinueMessage content = withAuthenticationResponseHeader 8 $
  lazyByteString content

-- | Issued by the backend to request SSPI credential authentication. The
-- frontend should respond by initiating a SSPI negotiation, sending a
-- 'PASSWORD_MESSAGE' with the first part of the SSPI data stream. If further
-- messages are needed, the server will respond with an
-- 'AUTHENTICATION_GSS_CONTINUE' message.
authenticationSSPIMessage :: Builder
authenticationSSPIMessage = withAuthenticationResponseHeader 9 mempty

authenticationSASLMessage :: Foldable t => t ByteString -> Builder
authenticationSASLMessage mechanisms = withAuthenticationResponseHeader 10 $
  foldMap byteStringNul mechanisms <>
  char8 '\0'

authenticationSASLContinueMessage :: LazyByteString -> Builder
authenticationSASLContinueMessage content = withAuthenticationResponseHeader 11 $
  lazyByteString content

authenticationSASLFinalMessage :: LazyByteString -> Builder
authenticationSASLFinalMessage content = withAuthenticationResponseHeader 12 $
  lazyByteString content

-- | A message of the form “@'AUTHENTICATION_MISCELLANEOUS' t x@” is used to
-- encode possible future authentication methods that are not recognized by the
-- current version of the library.  The 32-bit tag @t@ describes the
-- authentication method requested and @x@ described any authentication
-- parameters (possibly 'Data.ByteString.Lazy.null'), in the method-specific
-- format. The only sensible response to this message is to abandon the
-- connection after issuing an appropriate notification message to the user.
authenticationMiscellaneousMessage :: Word32 -> LazyByteString -> Builder
authenticationMiscellaneousMessage tag content = withAuthenticationResponseHeader tag $
  lazyByteString content

-- | A message of the form “@'BACKEND_KEY_DATA' pid k@” is sent by the backend
-- as part of the session establishment protocol, providing the frontend
-- process with the backend process ID @pid@ and secret @k@ required of the
-- frontend to issue query cancellation requests (see: 'CANCEL_QUERY' message
-- type above.)
backendKeyDataMessage :: ProcessID -> Word32 -> Builder
backendKeyDataMessage pid secret = withMessageHeader 'B' $
  word32BE pid <> word32BE secret

-- | Sent by the backend to indicate successful completion of a 'BIND' request.
bindCompleteMessage :: Builder
bindCompleteMessage = withMessageHeader '2' mempty

-- | Sent by the backend to indicate successful completion of a 'CLOSE'
-- request.
closeCompleteMessage :: Builder
closeCompleteMessage = withMessageHeader '3' mempty

-- | Sent by the backend to indicate successful completion of a 'QUERY' or
-- 'EXECUTE' request, after any query results have been returned through an
-- appropriate number of 'DATA_ROW' messages.
commandCompleteMessage :: LazyByteString -> Builder
commandCompleteMessage tag = withMessageHeader 'C' $
  lazyByteStringNul tag

-- | A message of the form “@'COPY_IN_RESPONSE' f fs@” is sent by the backend
-- to initiate an inbound @COPY@ subprotocol session with the frontend. The
-- frontend should respond with zero or more 'COPY_IN_DATA' messages followed
-- by a 'COPY_IN_DONE', or, if it is not prepared to do so, send a 'COPY_FAIL'
-- message back to the server.
--
-- The /stream format/ parameter @f@ defines the overall format of the data
-- stream requested by the backend, while the array @fs@ defines the transfer
-- formats of the individual data fields in each row, and must always be set to
-- 'TEXT_FORMAT' if the overall format of the stream @f@ is set to
-- 'TEXT_STREAM_FORMAT'.
copyInResponseMessage :: Foldable t => StreamFormat -> t Format -> Builder
copyInResponseMessage f fs = withMessageHeader 'G' $
  word8 f <> array16BE word16BE fs

-- | A message of the form “@'COPY_OUT_RESPONSE' f fs@” is sent by the backend
-- to initiate an outbound @COPY@ subprotocol session with the frontend. It
-- should be followed immediately by zero or more 'COPY_OUT_DATA' messages and
-- completed with 'COPY_OUT_DONE'.
--
-- The /stream format/ parameter @f@ defines the overall format of the data
-- stream requested by the backend, while the array @fs@ defines the transfer
-- formats of the individual data fields in each row, and must always be set to
-- 'TEXT_FORMAT' if the overall format of the stream @f@ is set to
-- 'TEXT_STREAM_FORMAT'.
copyOutResponseMessage :: Foldable t => StreamFormat -> t Format -> Builder
copyOutResponseMessage f fs = withMessageHeader 'H' $
  word8 f <> array16BE word16BE fs

-- | A message of the form “@'COPY_BOTH_RESPONSE' f fs@” is sent by the backend
-- to initiate a bidirectional @COPY@ subprotocol session, used only for
-- streaming replication.
--
-- The /stream format/ parameter @f@ defines the overall format of the data
-- stream requested by the backend, while the array @fs@ defines the transfer
-- formats of the individual data fields in each row, and must always be set to
-- 'TEXT_FORMAT' if the overall format of the stream @f@ is set to
-- 'TEXT_STREAM_FORMAT'.
copyBothResponseMessage :: Foldable t => StreamFormat -> t Format -> Builder
copyBothResponseMessage f fs = withMessageHeader 'W' $
  word8 f <> array16BE word16BE fs

-- | Sent by the backend with a list of column or field values returned from a
-- data set returning SQL query such as @SELECT@ or @FETCH@.
dataRowMessage :: Foldable t => t (Maybe LazyByteString) -> Builder
dataRowMessage vs = withMessageHeader 'D' $
  array16BE pgValue vs

-- | Sent by the backend in lieu of the 'COMMAND_COMPLETE' message as a
-- response to an attempt to execute an empty query string.
emptyQueryResponseMessage :: Builder
emptyQueryResponseMessage = withMessageHeader 'I' mempty

-- | Sent by the backend to indicate an error condition, with details of the
-- error communicated through a list of tagged /notice fields/ as described in
-- the definition of the 'NOTICE_FIELD_TAG'.
errorResponseMessage :: Foldable t => t NoticeField -> Builder
errorResponseMessage nfs = withMessageHeader 'E' $
  foldMap (uncurry mappend . bimap word8 lazyByteStringNul) nfs <>
  char8 '\0'

-- | Sent by the backend to indicate successful completion of a 'FUNCTION_CALL'
-- operation, with the sole value returned by the function call (possibly
-- @NULL@.)
functionCallResponseMessage :: Maybe LazyByteString -> Builder
functionCallResponseMessage v = withMessageHeader 'V' $
  pgValue v

-- | Sent by the backend in lieu of the 'ROW_DESCRIPTION' message, in response
-- to a 'DESCRIBE' message for a statement or portal which represents an SQL
-- command such as @CREATE@ or @INSERT@ that does not return a row set.
noDataMessage :: Builder
noDataMessage = withMessageHeader 'n' mempty

-- | Sent by the backend to inform the frontend of a condition such as a
-- warning or administrator action that may, or may be relevant to an operation
-- currently in progress and may be issued asynchronously to any other message
-- exchanges. Frontends must be prepared to accept such messages from the
-- backend at any time after the initial 'STARTUP_MESSAGE' of a communication
-- session.
noticeResponseMessage :: Foldable t => t NoticeField -> Builder
noticeResponseMessage nfs = withMessageHeader 'N' $
  foldMap (uncurry mappend . bimap word8 lazyByteStringNul) nfs <>
  char8 '\0'

-- | A message of the form “@'NOTIFICATION_RESPONSE pid' c x@” is sent by the
-- backend to inform the frontend of a @NOTIFY@ event issued by the backend
-- process @pid@, on the channel @c@ with a payload @x@. Frontends must be
-- prepared to accept such messages from the backend at any time after the
-- initial 'STARTUP_MESSAGE' of a communication session, irrespective of any
-- other message exchanges being conducted.
notificationResponseMessage :: ProcessID -> ByteString -> LazyByteString -> Builder
notificationResponseMessage pid c x = withMessageHeader 'A' $
  word32BE pid <>
  byteStringNul c <>
  lazyByteStringNul x

-- | Sent by the backend in response to a statement variant of a 'DESCRIBE'
-- message, with object IDs of the types of all parameters required by the
-- statement.
parameterDescriptionMessage :: Foldable t => t ObjectID -> Builder
parameterDescriptionMessage pts = withMessageHeader 't' $
  array16BE word32BE pts

-- | A message of the form “@'PARAMETER_STATUS' p x@” is sent by the backend
-- whenever of the “significant” session parameters is changed, either
-- explicitly by the user with the SQL @SET@ comand, or as a result of
-- administrator action.  Frontends must be prepared to accept such messages
-- from the backend at any time after the initial 'STARTUP_MESSAGE' of a
-- communication session, irrespective of any other message exchanges being
-- conducted.
--
-- What constitutes a “significant” message is currently left unspecified in
-- PostgreSQL documentation, and may even become configurable in future server
-- versions. At present time, these messages are issued for changes of the
-- following parameters: @server_version@, @server_encoding@,
-- @client_encoding@, @application_name@, @is_superuser@,
-- @session_authorization@, @DateStyle@, @IntervalStyle@, @TimeZone@,
-- @integer_datetimes@ and @standard_conforming_strings@.
parameterStatusMessage :: ByteString -> LazyByteString -> Builder
parameterStatusMessage p x = withMessageHeader 'S' $
  byteStringNul p <>
  lazyByteStringNul x

-- | Sent by the backend in response to a successful completion of a 'PARSE'
-- operation.
parseCompleteMessage :: Builder
parseCompleteMessage = withMessageHeader '1' mempty

-- | Sent by the backend after the maximum number of 'DATA_ROW' messages
-- requested by an 'EXECUTE' operation has been reached without exhausting the
-- entire result set.
portalSuspendedMessage :: Builder
portalSuspendedMessage = withMessageHeader 's' mempty

-- | Sent by the backend as a synchronization point, indicating readiness to
-- process a new SQL command, carrying with it the status of the current
-- transaction (if any.)
readyForQueryMessage :: TransactionStatus -> Builder
readyForQueryMessage ts = withMessageHeader 'Z' $
  word8 ts

-- | Sent by the backend at the beginning of a result set as part of a simple
-- or extended query protocol, or in response to a 'DESCRIBE' message referring
-- to an SQL command that returns a row set.
rowDescriptionMessage :: Foldable t => t FieldDescription -> Builder
rowDescriptionMessage fds = withMessageHeader 'T' $
  array16BE pgFieldDescription fds
 where
  pgFieldDescription fd =
    byteStringNul (fieldName fd) <>
    word32BE    (fieldTableID fd) <>
    int16BE     (fieldColumnID fd) <>
    word32BE    (fieldDataTypeID fd) <>
    int16BE     (fieldDataTypeSize fd) <>
    word32BE    (fieldDataTypeModifier fd) <>
    word16BE    (fieldFormat fd)
